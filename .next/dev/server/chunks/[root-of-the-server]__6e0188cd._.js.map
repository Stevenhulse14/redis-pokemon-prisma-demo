{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/profsteve/Documents/prisma-supabase-redis/lib/db.ts"],"sourcesContent":["import { Pool, PoolConfig } from \"pg\"\n\nlet pool: Pool | null = null\n\nexport function getSQL(): Pool {\n  if (pool) {\n    return pool\n  }\n\n  const databaseUrl = process.env.POSTGRES_PRISMA_URL || process.env.DATABASE_URL || process.env.POSTGRES_URL\n\n  if (!databaseUrl) {\n    throw new Error(\"No database URL found in environment variables. Please set POSTGRES_PRISMA_URL, DATABASE_URL, or POSTGRES_URL\")\n  }\n\n  // Check if it's a placeholder value\n  if (databaseUrl.includes(\"your_\") || databaseUrl === \"placeholder\" || databaseUrl.startsWith(\"https://\")) {\n    throw new Error(`Invalid database URL. Please set a valid PostgreSQL connection string in POSTGRES_PRISMA_URL. Current value: ${databaseUrl.substring(0, 50)}...`)\n  }\n\n  // Basic validation - should start with postgresql:// or postgres://\n  if (!databaseUrl.startsWith(\"postgresql://\") && !databaseUrl.startsWith(\"postgres://\")) {\n    throw new Error(`Invalid database URL format. Expected postgresql:// or postgres://, got: ${databaseUrl.substring(0, 50)}...`)\n  }\n\n  // Parse connection string to extract components\n  const url = new URL(databaseUrl)\n  const isSupabase = url.hostname.includes(\"supabase\") || url.hostname.includes(\"pooler\")\n\n  // Build pool config\n  const poolConfig: PoolConfig = {\n    host: url.hostname,\n    port: parseInt(url.port) || 5432,\n    database: url.pathname.slice(1), // Remove leading slash\n    user: url.username,\n    password: url.password,\n    // SSL configuration for Supabase\n    ssl: isSupabase\n      ? {\n          rejectUnauthorized: false, // Allow self-signed certificates\n        }\n      : undefined,\n    // Additional pool settings\n    max: 20,\n    idleTimeoutMillis: 30000,\n    connectionTimeoutMillis: 10000,\n  }\n\n  // Add query parameters if present\n  url.searchParams.forEach((value, key) => {\n    if (key === \"sslmode\") {\n      // Handle sslmode parameter\n      if (value === \"require\" || value === \"prefer\") {\n        poolConfig.ssl = poolConfig.ssl || { rejectUnauthorized: false }\n      }\n    }\n  })\n\n  pool = new Pool(poolConfig)\n\n  return pool\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;AAEA,IAAI,OAAoB;AAEjB,SAAS;IACd,IAAI,MAAM;QACR,OAAO;IACT;IAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,mBAAmB,IAAI,QAAQ,GAAG,CAAC,YAAY,IAAI,QAAQ,GAAG,CAAC,YAAY;IAE3G,IAAI,CAAC,aAAa;QAChB,MAAM,IAAI,MAAM;IAClB;IAEA,oCAAoC;IACpC,IAAI,YAAY,QAAQ,CAAC,YAAY,gBAAgB,iBAAiB,YAAY,UAAU,CAAC,aAAa;QACxG,MAAM,IAAI,MAAM,CAAC,6GAA6G,EAAE,YAAY,SAAS,CAAC,GAAG,IAAI,GAAG,CAAC;IACnK;IAEA,oEAAoE;IACpE,IAAI,CAAC,YAAY,UAAU,CAAC,oBAAoB,CAAC,YAAY,UAAU,CAAC,gBAAgB;QACtF,MAAM,IAAI,MAAM,CAAC,yEAAyE,EAAE,YAAY,SAAS,CAAC,GAAG,IAAI,GAAG,CAAC;IAC/H;IAEA,gDAAgD;IAChD,MAAM,MAAM,IAAI,IAAI;IACpB,MAAM,aAAa,IAAI,QAAQ,CAAC,QAAQ,CAAC,eAAe,IAAI,QAAQ,CAAC,QAAQ,CAAC;IAE9E,oBAAoB;IACpB,MAAM,aAAyB;QAC7B,MAAM,IAAI,QAAQ;QAClB,MAAM,SAAS,IAAI,IAAI,KAAK;QAC5B,UAAU,IAAI,QAAQ,CAAC,KAAK,CAAC;QAC7B,MAAM,IAAI,QAAQ;QAClB,UAAU,IAAI,QAAQ;QACtB,iCAAiC;QACjC,KAAK,aACD;YACE,oBAAoB;QACtB,IACA;QACJ,2BAA2B;QAC3B,KAAK;QACL,mBAAmB;QACnB,yBAAyB;IAC3B;IAEA,kCAAkC;IAClC,IAAI,YAAY,CAAC,OAAO,CAAC,CAAC,OAAO;QAC/B,IAAI,QAAQ,WAAW;YACrB,2BAA2B;YAC3B,IAAI,UAAU,aAAa,UAAU,UAAU;gBAC7C,WAAW,GAAG,GAAG,WAAW,GAAG,IAAI;oBAAE,oBAAoB;gBAAM;YACjE;QACF;IACF;IAEA,OAAO,IAAI,4GAAI,CAAC;IAEhB,OAAO;AACT"}},
    {"offset": {"line": 123, "column": 0}, "map": {"version":3,"sources":["file:///Users/profsteve/Documents/prisma-supabase-redis/lib/redis.ts"],"sourcesContent":["/**\n * Upstash Redis REST API client\n * Uses the REST API instead of node-redis to work in browser-based environments like v0\n */\nclass UpstashRedis {\n  private url: string\n  private token: string\n\n  constructor(url: string, token: string) {\n    this.url = url\n    this.token = token\n  }\n\n  private async handleResponse(response: Response): Promise<any> {\n    if (!response.ok) {\n      const text = await response.text()\n      throw new Error(`Redis API error: ${text}`)\n    }\n\n    const text = await response.text()\n    try {\n      return JSON.parse(text)\n    } catch {\n      throw new Error(`Invalid JSON response: ${text}`)\n    }\n  }\n\n  async get(key: string): Promise<string | null> {\n    try {\n      const response = await fetch(`${this.url}/get/${key}`, {\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n        },\n      })\n      const data = await this.handleResponse(response)\n      return data.result\n    } catch (error) {\n      console.error(\"[redis] GET error:\", error)\n      return null\n    }\n  }\n\n  async set(key: string, value: string, options?: { EX?: number }): Promise<string | null> {\n    try {\n      const commands = options?.EX ? [\"SET\", key, value, \"EX\", options.EX.toString()] : [\"SET\", key, value]\n\n      const response = await fetch(`${this.url}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(commands),\n      })\n      const data = await this.handleResponse(response)\n      return data.result\n    } catch (error) {\n      console.error(\"[redis] SET error:\", error)\n      return null\n    }\n  }\n\n  async incr(key: string): Promise<number> {\n    try {\n      const response = await fetch(`${this.url}/incr/${key}`, {\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n        },\n      })\n      const data = await this.handleResponse(response)\n      return data.result\n    } catch (error) {\n      console.error(\"[redis] INCR error:\", error)\n      return 0\n    }\n  }\n\n  async mGet(keys: string[]): Promise<(string | null)[]> {\n    try {\n      const commands = [\"MGET\", ...keys]\n      const response = await fetch(`${this.url}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(commands),\n      })\n      const data = await this.handleResponse(response)\n      return data.result\n    } catch (error) {\n      console.error(\"[redis] MGET error:\", error)\n      return keys.map(() => null)\n    }\n  }\n\n  async del(key: string): Promise<number> {\n    try {\n      const response = await fetch(`${this.url}/del/${key}`, {\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n        },\n      })\n      const data = await this.handleResponse(response)\n      return data.result\n    } catch (error) {\n      console.error(\"[redis] DEL error:\", error)\n      return 0\n    }\n  }\n}\n\nlet redisClient: UpstashRedis | null = null\n\nexport function getRedis(): UpstashRedis | null {\n  if (redisClient) return redisClient\n\n  const url = process.env.KV_REST_API_URL\n  const token = process.env.KV_REST_API_TOKEN\n\n  if (!url || !token) {\n    console.warn(\"[redis] Upstash credentials not found. Redis caching disabled.\")\n    return null\n  }\n\n  redisClient = new UpstashRedis(url, token)\n  return redisClient\n}\n\nexport const redis = getRedis()\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 262, "column": 0}, "map": {"version":3,"sources":["file:///Users/profsteve/Documents/prisma-supabase-redis/app/api/pokemon/%5Bid%5D/route.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from \"next/server\"\nimport { getSQL } from \"@/lib/db\"\nimport { redis } from \"@/lib/redis\"\n\nconst POKEMON_TTL_SECONDS = 300\n\nexport async function GET(_req: NextRequest, context: { params: Promise<{ id: string }> }) {\n  const params = await context.params\n  const idParam = params.id\n  const id = Number(idParam)\n\n  if (Number.isNaN(id) || id <= 0) {\n    return NextResponse.json({ error: \"Invalid Pokémon ID\" }, { status: 400 })\n  }\n\n  const cacheKey = `pokemon:${id}`\n\n  try {\n    // 1. Try cache first\n    if (redis) {\n      try {\n        const cached = await redis.get(cacheKey)\n        if (cached) {\n          const pokemon = JSON.parse(cached)\n          await redis.incr(\"metrics:hits\").catch(() => {})\n          return NextResponse.json({ pokemon, source: \"cache\" as const }, { status: 200 })\n        }\n      } catch (error) {\n        console.error(\"[redis] Cache read error:\", error)\n      }\n    }\n\n    // 2. Cache miss → hit DB with direct SQL\n    const db = getSQL()\n    const result = await db.query(\n      `SELECT \n        id, \n        name, \n        \"spriteUrl\", \n        \"typePrimary\", \n        \"typeSecondary\",\n        hp,\n        attack,\n        defense,\n        speed,\n        \"createdAt\",\n        \"updatedAt\"\n      FROM \"Pokemon\"\n      WHERE id = $1\n      LIMIT 1`,\n      [id]\n    )\n\n    if (result.rows.length === 0) {\n      return NextResponse.json({ error: \"Pokémon not found\" }, { status: 404 })\n    }\n\n    const pokemon = result.rows[0]\n\n    // 3. Store in cache for next time\n    if (redis) {\n      try {\n        await redis.set(cacheKey, JSON.stringify(pokemon), { EX: POKEMON_TTL_SECONDS })\n        await redis.incr(\"metrics:misses\")\n      } catch (error) {\n        console.error(\"[redis] Cache write error:\", error)\n      }\n    }\n\n    return NextResponse.json({ pokemon, source: \"db\" as const }, { status: 200 })\n  } catch (error) {\n    console.error(\"[api/pokemon/[id]] Error:\", error)\n    return NextResponse.json(\n      {\n        error: \"Internal server error\",\n        message: error instanceof Error ? error.message : \"Unknown error\",\n      },\n      { status: 500 },\n    )\n  }\n}\n\n// POST endpoint to bust cache\nexport async function POST(_req: NextRequest, context: { params: Promise<{ id: string }> }) {\n  const params = await context.params\n  const idParam = params.id\n  const id = Number(idParam)\n\n  if (Number.isNaN(id) || id <= 0) {\n    return NextResponse.json({ error: \"Invalid Pokémon ID\" }, { status: 400 })\n  }\n\n  const cacheKey = `pokemon:${id}`\n\n  try {\n    if (redis) {\n      try {\n        await redis.del(cacheKey)\n      } catch (error) {\n        console.error(\"[redis] Delete error:\", error)\n      }\n    }\n\n    return NextResponse.json({ message: \"Cache busted successfully\" }, { status: 200 })\n  } catch (error) {\n    console.error(\"[api/pokemon/[id]] Cache bust error:\", error)\n    return NextResponse.json({ error: \"Failed to bust cache\" }, { status: 500 })\n  }\n}\n\n// Function to increment metrics\nasync function incrementMetric(kind: \"hits\" | \"misses\") {\n  if (!redis) return\n  const key = `metrics:${kind}`\n  try {\n    await redis.incr(key)\n  } catch (error) {\n    console.warn(`[metrics] Failed to increment ${kind}:`, error)\n  }\n}\n"],"names":[],"mappings":"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"}}]
}