{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/profsteve/Documents/prisma-supabase-redis/lib/db.ts"],"sourcesContent":["import { Pool, PoolConfig } from \"pg\"\n\nlet pool: Pool | null = null\n\nexport function getSQL(): Pool {\n  if (pool) {\n    return pool\n  }\n\n  const databaseUrl = process.env.POSTGRES_PRISMA_URL || process.env.DATABASE_URL || process.env.POSTGRES_URL\n\n  if (!databaseUrl) {\n    throw new Error(\"No database URL found in environment variables. Please set POSTGRES_PRISMA_URL, DATABASE_URL, or POSTGRES_URL\")\n  }\n\n  // Check if it's a placeholder value\n  if (databaseUrl.includes(\"your_\") || databaseUrl === \"placeholder\" || databaseUrl.startsWith(\"https://\")) {\n    throw new Error(`Invalid database URL. Please set a valid PostgreSQL connection string in POSTGRES_PRISMA_URL. Current value: ${databaseUrl.substring(0, 50)}...`)\n  }\n\n  // Basic validation - should start with postgresql:// or postgres://\n  if (!databaseUrl.startsWith(\"postgresql://\") && !databaseUrl.startsWith(\"postgres://\")) {\n    throw new Error(`Invalid database URL format. Expected postgresql:// or postgres://, got: ${databaseUrl.substring(0, 50)}...`)\n  }\n\n  // Parse connection string to extract components\n  const url = new URL(databaseUrl)\n  const isSupabase = url.hostname.includes(\"supabase\") || url.hostname.includes(\"pooler\")\n\n  // Build pool config\n  const poolConfig: PoolConfig = {\n    host: url.hostname,\n    port: parseInt(url.port) || 5432,\n    database: url.pathname.slice(1), // Remove leading slash\n    user: url.username,\n    password: url.password,\n    // SSL configuration for Supabase\n    ssl: isSupabase\n      ? {\n          rejectUnauthorized: false, // Allow self-signed certificates\n        }\n      : undefined,\n    // Additional pool settings\n    max: 20,\n    idleTimeoutMillis: 30000,\n    connectionTimeoutMillis: 10000,\n  }\n\n  // Add query parameters if present\n  url.searchParams.forEach((value, key) => {\n    if (key === \"sslmode\") {\n      // Handle sslmode parameter\n      if (value === \"require\" || value === \"prefer\") {\n        poolConfig.ssl = poolConfig.ssl || { rejectUnauthorized: false }\n      }\n    }\n  })\n\n  pool = new Pool(poolConfig)\n\n  return pool\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;AAEA,IAAI,OAAoB;AAEjB,SAAS;IACd,IAAI,MAAM;QACR,OAAO;IACT;IAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,mBAAmB,IAAI,QAAQ,GAAG,CAAC,YAAY,IAAI,QAAQ,GAAG,CAAC,YAAY;IAE3G,IAAI,CAAC,aAAa;QAChB,MAAM,IAAI,MAAM;IAClB;IAEA,oCAAoC;IACpC,IAAI,YAAY,QAAQ,CAAC,YAAY,gBAAgB,iBAAiB,YAAY,UAAU,CAAC,aAAa;QACxG,MAAM,IAAI,MAAM,CAAC,6GAA6G,EAAE,YAAY,SAAS,CAAC,GAAG,IAAI,GAAG,CAAC;IACnK;IAEA,oEAAoE;IACpE,IAAI,CAAC,YAAY,UAAU,CAAC,oBAAoB,CAAC,YAAY,UAAU,CAAC,gBAAgB;QACtF,MAAM,IAAI,MAAM,CAAC,yEAAyE,EAAE,YAAY,SAAS,CAAC,GAAG,IAAI,GAAG,CAAC;IAC/H;IAEA,gDAAgD;IAChD,MAAM,MAAM,IAAI,IAAI;IACpB,MAAM,aAAa,IAAI,QAAQ,CAAC,QAAQ,CAAC,eAAe,IAAI,QAAQ,CAAC,QAAQ,CAAC;IAE9E,oBAAoB;IACpB,MAAM,aAAyB;QAC7B,MAAM,IAAI,QAAQ;QAClB,MAAM,SAAS,IAAI,IAAI,KAAK;QAC5B,UAAU,IAAI,QAAQ,CAAC,KAAK,CAAC;QAC7B,MAAM,IAAI,QAAQ;QAClB,UAAU,IAAI,QAAQ;QACtB,iCAAiC;QACjC,KAAK,aACD;YACE,oBAAoB;QACtB,IACA;QACJ,2BAA2B;QAC3B,KAAK;QACL,mBAAmB;QACnB,yBAAyB;IAC3B;IAEA,kCAAkC;IAClC,IAAI,YAAY,CAAC,OAAO,CAAC,CAAC,OAAO;QAC/B,IAAI,QAAQ,WAAW;YACrB,2BAA2B;YAC3B,IAAI,UAAU,aAAa,UAAU,UAAU;gBAC7C,WAAW,GAAG,GAAG,WAAW,GAAG,IAAI;oBAAE,oBAAoB;gBAAM;YACjE;QACF;IACF;IAEA,OAAO,IAAI,4GAAI,CAAC;IAEhB,OAAO;AACT"}},
    {"offset": {"line": 195, "column": 0}, "map": {"version":3,"sources":["file:///Users/profsteve/Documents/prisma-supabase-redis/lib/redis.ts"],"sourcesContent":["/**\n * Upstash Redis REST API client\n * Uses the REST API instead of node-redis to work in browser-based environments like v0\n */\nclass UpstashRedis {\n  private url: string;\n  private token: string;\n\n  constructor(url: string, token: string) {\n    this.url = url;\n    this.token = token;\n  }\n\n  private async handleResponse(response: Response): Promise<any> {\n    if (!response.ok) {\n      const text = await response.text();\n      throw new Error(`Redis API error: ${text}`);\n    }\n\n    const text = await response.text();\n    try {\n      return JSON.parse(text);\n    } catch {\n      throw new Error(`Invalid JSON response: ${text}`);\n    }\n  }\n\n  async get(key: string): Promise<string | null> {\n    try {\n      const response = await fetch(`${this.url}/get/${key}`, {\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n        },\n      });\n      const data = await this.handleResponse(response);\n      return data.result;\n    } catch (error) {\n      console.error(\"[redis] GET error:\", error);\n      return null;\n    }\n  }\n\n  async set(\n    key: string,\n    value: string,\n    options?: { EX?: number }\n  ): Promise<string | null> {\n    try {\n      const commands = options?.EX\n        ? [\"SET\", key, value, \"EX\", options.EX.toString()]\n        : [\"SET\", key, value];\n\n      const response = await fetch(`${this.url}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(commands),\n      });\n      const data = await this.handleResponse(response);\n      return data.result;\n    } catch (error) {\n      console.error(\"[redis] SET error:\", error);\n      return null;\n    }\n  }\n\n  async incr(key: string): Promise<number> {\n    try {\n      const response = await fetch(`${this.url}/incr/${key}`, {\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n        },\n      });\n      const data = await this.handleResponse(response);\n      return data.result;\n    } catch (error) {\n      console.error(\"[redis] INCR error:\", error);\n      return 0;\n    }\n  }\n\n  async mGet(keys: string[]): Promise<(string | null)[]> {\n    try {\n      const commands = [\"MGET\", ...keys];\n      const response = await fetch(`${this.url}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(commands),\n      });\n      const data = await this.handleResponse(response);\n      return data.result;\n    } catch (error) {\n      console.error(\"[redis] MGET error:\", error);\n      return keys.map(() => null);\n    }\n  }\n\n  async del(key: string): Promise<number> {\n    try {\n      const response = await fetch(`${this.url}/del/${key}`, {\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n        },\n      });\n      const data = await this.handleResponse(response);\n      return data.result;\n    } catch (error) {\n      console.error(\"[redis] DEL error:\", error);\n      return 0;\n    }\n  }\n}\n\n// Support both Upstash REST API and standard Redis\nlet redisClient: UpstashRedis | any | null = null;\n\nexport function getRedis(): UpstashRedis | any | null {\n  if (redisClient) return redisClient;\n\n  // Try Upstash REST API first (for serverless environments)\n  const upstashUrl = process.env.KV_REST_API_URL;\n  const upstashToken = process.env.KV_REST_API_TOKEN;\n\n  if (upstashUrl && upstashToken) {\n    console.log(\"[redis] Using Upstash REST API\");\n    redisClient = new UpstashRedis(upstashUrl, upstashToken);\n    return redisClient;\n  }\n\n  // Try standard Redis connection\n  const redisUrl = process.env.REDIS_URL;\n  if (redisUrl) {\n    try {\n      console.log(\"[redis] Using standard Redis connection:\", redisUrl);\n      const { createClient } = require(\"redis\");\n      const client = createClient({\n        url: redisUrl,\n        socket: {\n          reconnectStrategy: (retries: number) => {\n            if (retries > 10) {\n              console.error(\"[redis] Max reconnection attempts reached\");\n              return new Error(\"Max reconnection attempts reached\");\n            }\n            return Math.min(retries * 100, 3000);\n          },\n        },\n      });\n\n      // Handle connection events\n      client.on(\"error\", (err: Error) => {\n        console.error(\"[redis] Client error:\", err.message);\n      });\n\n      client.on(\"connect\", () => {\n        console.log(\"[redis] Connected to Redis\");\n      });\n\n      client.on(\"ready\", () => {\n        console.log(\"[redis] Redis client ready\");\n      });\n\n      client.on(\"reconnecting\", () => {\n        console.log(\"[redis] Reconnecting to Redis...\");\n      });\n\n      // Connect the client\n      client.connect().catch((err: Error) => {\n        console.error(\"[redis] Initial connection error:\", err.message);\n      });\n\n      // Helper function to ensure connection\n      async function ensureConnected() {\n        if (!client.isOpen) {\n          try {\n            await client.connect();\n          } catch (error: any) {\n            // Ignore \"already connecting\" errors\n            if (\n              !error.message?.includes(\"already connecting\") &&\n              !error.message?.includes(\"Socket already opened\")\n            ) {\n              throw error;\n            }\n          }\n        }\n      }\n\n      // Wrap standard Redis client to match Upstash API\n      redisClient = {\n        async get(key: string): Promise<string | null> {\n          try {\n            await ensureConnected();\n            return await client.get(key);\n          } catch (error: any) {\n            console.error(\"[redis] GET error:\", error.message || error);\n            return null;\n          }\n        },\n        async set(\n          key: string,\n          value: string,\n          options?: { EX?: number }\n        ): Promise<string | null> {\n          try {\n            await ensureConnected();\n            if (options?.EX) {\n              await client.setEx(key, options.EX, value);\n            } else {\n              await client.set(key, value);\n            }\n            return \"OK\";\n          } catch (error: any) {\n            console.error(\"[redis] SET error:\", error.message || error);\n            return null;\n          }\n        },\n        async incr(key: string): Promise<number> {\n          try {\n            await ensureConnected();\n            return await client.incr(key);\n          } catch (error: any) {\n            console.error(\"[redis] INCR error:\", error.message || error);\n            return 0;\n          }\n        },\n        async del(key: string): Promise<number> {\n          try {\n            await ensureConnected();\n            return await client.del(key);\n          } catch (error: any) {\n            console.error(\"[redis] DEL error:\", error.message || error);\n            return 0;\n          }\n        },\n        async mGet(keys: string[]): Promise<(string | null)[]> {\n          try {\n            await ensureConnected();\n            const results = await client.mGet(keys);\n            return results;\n          } catch (error: any) {\n            console.error(\"[redis] MGET error:\", error.message || error);\n            return keys.map(() => null);\n          }\n        },\n      };\n      return redisClient;\n    } catch (error) {\n      console.error(\"[redis] Failed to initialize Redis client:\", error);\n      console.warn(\"[redis] Redis caching disabled.\");\n      return null;\n    }\n  }\n\n  console.warn(\n    \"[redis] No Redis credentials found. Set KV_REST_API_URL/KV_REST_API_TOKEN (Upstash) or REDIS_URL (standard Redis). Redis caching disabled.\"\n  );\n  return null;\n}\n\nexport const redis = getRedis();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 446, "column": 0}, "map": {"version":3,"sources":["file:///Users/profsteve/Documents/prisma-supabase-redis/app/api/pokemon/%5Bid%5D/route.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from \"next/server\";\nimport { getSQL } from \"@/lib/db\";\nimport { redis } from \"@/lib/redis\";\n\nconst POKEMON_TTL_SECONDS = 300;\n\nexport async function GET(\n  _req: NextRequest,\n  context: { params: Promise<{ id: string }> }\n) {\n  const params = await context.params;\n  const idParam = params.id;\n  const id = Number(idParam);\n\n  if (Number.isNaN(id) || id <= 0) {\n    return NextResponse.json({ error: \"Invalid Pokémon ID\" }, { status: 400 });\n  }\n\n  const cacheKey = `pokemon:${id}`;\n\n  try {\n    // 1. Try cache first\n    if (redis) {\n      try {\n        const cached = await redis.get(cacheKey);\n        if (cached) {\n          const pokemon = JSON.parse(cached);\n          await redis.incr(\"metrics:hits\").catch(() => {});\n          return NextResponse.json(\n            { pokemon, source: \"cache\" as const },\n            { status: 200 }\n          );\n        }\n      } catch (error) {\n        console.error(\"[redis] Cache read error:\", error);\n      }\n    }\n\n    // 2. Cache miss → hit DB with direct SQL\n    const db = getSQL();\n    const result = await db.query(\n      `SELECT \n        id, \n        name, \n        \"spriteUrl\", \n        \"typePrimary\", \n        \"typeSecondary\",\n        hp,\n        attack,\n        defense,\n        \"specialAttack\",\n        \"specialDefense\",\n        speed,\n        \"createdAt\",\n        \"updatedAt\"\n      FROM \"Pokemon\"\n      WHERE id = $1\n      LIMIT 1`,\n      [id]\n    );\n\n    if (result.rows.length === 0) {\n      return NextResponse.json({ error: \"Pokémon not found\" }, { status: 404 });\n    }\n\n    const pokemon = result.rows[0];\n\n    // 3. Store in cache for next time\n    if (redis) {\n      try {\n        await redis.set(cacheKey, JSON.stringify(pokemon), {\n          EX: POKEMON_TTL_SECONDS,\n        });\n        await redis.incr(\"metrics:misses\");\n      } catch (error) {\n        console.error(\"[redis] Cache write error:\", error);\n      }\n    }\n\n    return NextResponse.json(\n      { pokemon, source: \"db\" as const },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error(\"[api/pokemon/[id]] Error:\", error);\n    return NextResponse.json(\n      {\n        error: \"Internal server error\",\n        message: error instanceof Error ? error.message : \"Unknown error\",\n      },\n      { status: 500 }\n    );\n  }\n}\n\n// POST endpoint to bust cache\nexport async function POST(\n  _req: NextRequest,\n  context: { params: Promise<{ id: string }> }\n) {\n  const params = await context.params;\n  const idParam = params.id;\n  const id = Number(idParam);\n\n  if (Number.isNaN(id) || id <= 0) {\n    return NextResponse.json({ error: \"Invalid Pokémon ID\" }, { status: 400 });\n  }\n\n  const cacheKey = `pokemon:${id}`;\n\n  try {\n    if (redis) {\n      try {\n        await redis.del(cacheKey);\n      } catch (error) {\n        console.error(\"[redis] Delete error:\", error);\n      }\n    }\n\n    return NextResponse.json(\n      { message: \"Cache busted successfully\" },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error(\"[api/pokemon/[id]] Cache bust error:\", error);\n    return NextResponse.json(\n      { error: \"Failed to bust cache\" },\n      { status: 500 }\n    );\n  }\n}\n\n// Function to increment metrics\nasync function incrementMetric(kind: \"hits\" | \"misses\") {\n  if (!redis) return;\n  const key = `metrics:${kind}`;\n  try {\n    await redis.incr(key);\n  } catch (error) {\n    console.warn(`[metrics] Failed to increment ${kind}:`, error);\n  }\n}\n"],"names":[],"mappings":"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"}}]
}